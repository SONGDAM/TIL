알고리즘은 문제 해결의 관점에서 보면 알고리즘은 문제를 해결하는 단계적 방법이다. 그럼 우리가 원하는 문제를 풀기 위해서는 어떤 알고리즘을 사용해야할까?

문제를 가정해보자.

우리에게 아주많은 이름들과 아주 많은 숫자들이 있다. 그리고 그 이름들은 a부터 z까지 알파벳 순서로 정렬되어있다. 한권의 책에 말이다.

hala라는 이름을 찾기 위해선 어떻게 해야할까? a부터 Z까지? 수백장의 종이를 한장씩 넘겨야한다. 그걸 두 배 빠르게 하려면? 책을 반으로 쪼갠다? 조금 더 쉽게 생각해보자 1,2,3,4,5,6의 순으로 넘기던 책을 2,4,6,8,10으로 넘기는 것이다. 2배더 빠르지만 반대로 어딘가에 있을 hala의 이름을 지나칠 수도 있다.

거기다가 1000페이지가 넘는다면? 기본적으로 어딘가에 있을 hala의 이름에 접근하기 위해 500번이상 페이지를 넘겨야 할 것이다. 그렇다면 과거의 우리는 이렇게 복잡한 문제를 어떻게 해결했을까?

hala면 h가 적혀있는 작은 부분을 찾아서 펼치지 않았을까? 전화번호가 1024쪽이라고 하자. 우리는 hala를 찾기 위해 이 문제를 나눠서 생각하는 것이다. 문제를 반으로 나누고 나눠 1024 => 512 => 256 => 128 => 64 => 32 => 8 => 4 => 2 결국 1페이지까지, 우리는 총 10단게만에 특정이름을 찾을 수 있다.

대부분의 경우 문제 해결은 내가 가지고 있는 직관이나 생각들을 기계나 다른 사람들이 이해할 수 있는 방식으로 번역하는 것이다. 그럼 어떤 알고리즘이 좋은 지는 어떻게 알 수 있을까. 우리는 여기서 이 생각, 직관 알고리즘을을 코드로 나타내보자.

이걸 sudo code라고 한다
sudo code는 영어로든 우리의 생각을 간결하게 정리한 코드와 비슷한 구문을 말한다. 이것을 영어로 표현한다면? 띄워쓰기는 가정에 따라 실행되는 것들이다.

pick up the phone book
Open to middle of phone book
Look at page
If Smith is on page
call Mik
Else If Smith is earlier in book
Open to middle of left half of book
Go back to line 3
Else if
Quit

아.. prettier로 인해 들여쓰기가 되지 않는다..

우리는 여기서 동작하는 부분을 함수라고 부르기로 했다. 함수는 컴퓨터에게 이 경우에는 사람에게 뭘할지 알려주는 동사와 같다. if 또는 Else if 들은 이제 조건이라고 부를 것이다. 하지만 결정을 내리기 위해서는 스스로에게 물어볼 질문이 필요하다. 참인지 거짓인지. 우리는 이것을 불린 표현이라고 한다 수학자 Boole의 이름을 따서말이다.(오 불린이 여기서 온 것인가..)

저 조건들은 답이 예 또는 아니오로 나오는 혹은 참 또는 거짓으로 나오는 것이다.
그리고 다시 3번줄로 돌아가라는 저 줄은 순환이라고 부르기로 했다.
