## 재귀

<hr>

재귀는 자기 자신을 호출하는 것이다. 똑같은 코드나 작업을 반복하여 사용할떄 반복문을 대체 할 수 있으며 특정 조건을 걸지 않는다면 stack overflow를 경험할 수 있다(?) js 에서는 maximum call stack size exceeded를 경험할 수 있다.

1. 반복문을 통한 구현

```js
for (let i = 0; i < 10; i++) {
  console.log(i);
}
```

0부터 10까지의 숫자가 출력된다. 위의 코드는 간단하지만 이중으로 for loop이 들어가고 그 사이 로직이 복잡하다면 위의 함수처럼 반복문을 사용하기 힘들수도 있다. 그렇다면 이번엔 재귀를 이용해 0부터 10까지 모두 더해보는 함수를 만들어보자.

```js
function recursion(n) {
  if (n <= 0) {
    return 0;
  }
  return n + recursion(n - 1);
}

console.log(recursion(10));
```

코드가 훨씬 간결해졌다.

<br>

### 병합 정렬

<hr>

버블 정렬, 선택 정렬의 단점은 모두 루프 두번 돌아야한다는 점이다. 즉 더 많은 시간이 소요된다.
병합정렬은 재귀를 통해 분할 정복 탐색처럼 자료가 한개가 될때까지 계속해서 반으로 자르고 정렬한뒤 다시 합쳐나가며 정렬을 하는 것이다.

마찬가지로 다음 숫자들을 오름차순으로 정렬해보자

<br>

7 4 5 2 6 3 8 1

<br>

먼저 숫자들을 반으로 나누자.

<br>

7 4 5 2 | 6 3 8 1

<br>

그리고 나눠진 부분 중 첫번째를 한번 더 반으로 나눠보자.

<br>

7 4 | 5 2 | 6 3 8 1

<br>

마지막으로 한 번 더 나눠보자.

<br>

7 | 4 | 5 2 | 6 3 8 1

이제 숫자가 두개 밖에 남지 않았기 때문에 7과 4를 비교해서 병합한다.
5와 2도 똑같은 방식으로 정렬한다.

그렇게되면

<br>

4 7| 2 5 | 6 3 8 1

<br>

그리고 반대편도 다시하면

<br>

4 7 | 2 5 | 3 6 | 1 8

<br>

그리고 다시 메모리 공간을 확보해서

좌측의 자료 두개를 합치고 정렬한다.

그리고 우측의 자료도 똑같은 방법으로 정렬한다

<br>
2 4 5 7 | 1 3 6 8

<br>

그리고 그 다음에 정렬하는 것이다.
이렇게 병합정렬로 자료를 정렬할 수 있다.

1 2 3 4 5 6 7 8

병합 정렬 실행 시간의 상한은 O(n log n) 이다.
숫자들을 반으로 나누는 데는 O(log n)의 시간이 들고, 각 반으로 나눈 부분들을 다시 정렬해서 병합하는 데 각각 O(n)의 시간이 걸리기 때문이다.
